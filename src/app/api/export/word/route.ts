import { NextResponse } from "next/server";
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, UnderlineType } from "docx";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function POST(request: Request) {
    try {
        // Check authentication
        const session = await getServerSession(authOptions);
        if (!session?.user) {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        const { analysisId } = await request.json();

        if (!analysisId) {
            return NextResponse.json({ error: "Analysis ID is required" }, { status: 400 });
        }

        // Fetch analysis and report data
        const analysis = await prisma.analysis.findUnique({
            where: { id: analysisId },
            include: {
                repository: true,
                reports: true,
            },
        });

        if (!analysis || !analysis.reports || analysis.reports.length === 0) {
            return NextResponse.json({ error: "Document not found" }, { status: 404 });
        }

        // Parse the book data
        const bookData = JSON.parse(analysis.reports[0].markdown);

        // Helper function to convert markdown to simple paragraphs
        const markdownToParagraphs = (content: string): Paragraph[] => {
            const lines = content.split('\n');
            const paragraphs: Paragraph[] = [];

            for (const line of lines) {
                const trimmed = line.trim();

                if (!trimmed) {
                    paragraphs.push(new Paragraph({ text: "" }));
                    continue;
                }

                // Headings
                if (trimmed.startsWith('### ')) {
                    paragraphs.push(new Paragraph({
                        text: trimmed.substring(4),
                        heading: HeadingLevel.HEADING_3,
                        spacing: { before: 240, after: 120 },
                    }));
                } else if (trimmed.startsWith('## ')) {
                    paragraphs.push(new Paragraph({
                        text: trimmed.substring(3),
                        heading: HeadingLevel.HEADING_2,
                        spacing: { before: 320, after: 160 },
                    }));
                } else if (trimmed.startsWith('# ')) {
                    paragraphs.push(new Paragraph({
                        text: trimmed.substring(2),
                        heading: HeadingLevel.HEADING_1,
                        spacing: { before: 400, after: 200 },
                    }));
                }
                // Lists
                else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
                    paragraphs.push(new Paragraph({
                        text: trimmed.substring(2),
                        bullet: { level: 0 },
                        spacing: { before: 80, after: 80 },
                    }));
                }
                // Code blocks - skip markers
                else if (trimmed.startsWith('```')) {
                    continue;
                }
                // Regular text
                else {
                    // Remove markdown formatting for simplicity
                    const cleanText = trimmed
                        .replace(/\*\*(.*?)\*\*/g, '$1')  // Remove bold
                        .replace(/\*(.*?)\*/g, '$1')      // Remove italic
                        .replace(/`(.*?)`/g, '$1');       // Remove code

                    paragraphs.push(new Paragraph({
                        text: cleanText,
                        spacing: { before: 100, after: 100 },
                    }));
                }
            }

            return paragraphs;
        };

        // Create Word document
        const doc = new Document({
            sections: [{
                properties: {},
                children: [
                    // Title
                    new Paragraph({
                        text: bookData.title,
                        heading: HeadingLevel.TITLE,
                        alignment: AlignmentType.CENTER,
                        spacing: { before: 1200, after: 400 },
                    }),
                    new Paragraph({
                        text: "Automated Technical Documentation",
                        alignment: AlignmentType.CENTER,
                        spacing: { after: 200 },
                    }),
                    new Paragraph({
                        text: "Generated by GitDoc",
                        alignment: AlignmentType.CENTER,
                        spacing: { after: 800 },
                    }),

                    // Chapters
                    ...bookData.chapters.flatMap((chapter: any) => [
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_1,
                            pageBreakBefore: true,
                            spacing: { before: 400, after: 300 },
                        }),
                        ...markdownToParagraphs(chapter.content),
                    ]),
                ],
            }],
        });

        // Generate Word document buffer
        const buffer = await Packer.toBuffer(doc);

        // Return Word document as response
        return new NextResponse(new Uint8Array(buffer), {
            headers: {
                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'Content-Disposition': `attachment; filename="${bookData.title.replace(/[^a-z0-9]/gi, '_')}.docx"`,
            },
        });

    } catch (error: any) {
        console.error("Word export error:", error);
        return NextResponse.json(
            { error: error.message || "Failed to generate Word document" },
            { status: 500 }
        );
    }
}
